# -*- coding: utf-8 -*-
"""Untitled3.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HHeaelSZCGDRSvfC2CuTa-nq_QldpI_F
"""

import streamlit as st
import pandas as pd
import numpy as np
import altair as alt

# Define the Streamlit app title
st.title('Tourism in Lebanese Districts')

# Define the data path
# When deploying to Streamlit Community Cloud, the data file needs to be
# in the same repository as your app file, or accessible via a URL.
# Assuming '1bda8ed51f92f19f06887a3d1c8afaba.csv' is in the same directory
DATA_PATH = "1bda8ed51f92f19f06887a3d1c8afaba.csv"

# Load the data with caching
@st.cache_data
def load_data(data_path):
    data = pd.read_csv(data_path)
    # Ensure 'refArea' and 'Town' are treated as strings
    if 'refArea' in data.columns:
        data['refArea'] = data['refArea'].astype(str)
    if 'Town' in data.columns:
        data['Town'] = data['Town'].astype(str)
    return data

# Load the data and display loading status
data_load_state = st.text('Loading data...')
data = load_data(DATA_PATH)
data_load_state.text("Done! Loading data...")

# Interactive feature 1: Display raw data checkbox
if st.checkbox('Show raw data'):
    st.subheader('Raw data')
    st.write(data)

# Interactive feature: Search bar for filtering by Town
st.sidebar.subheader('Filter Data by Town')
town_search_term = st.sidebar.text_input('Enter Town Name to Search')

# Filter data based on search term
if town_search_term:
    # Use case=False for case-insensitive search and na=False to handle potential NaN values
    filtered_data = data[data['Town'].str.contains(town_search_term, case=False, na=False)]
else:
    filtered_data = data.copy() # Use a copy to avoid modifying the original cached data

# Interactive feature: Slider for filtering by Tourism Index
st.sidebar.subheader('Filter by Tourism Index')
min_tourism_index, max_tourism_index = int(data['Tourism Index'].min()), int(data['Tourism Index'].max())
tourism_index_filter_range = st.sidebar.slider(
    'Select Tourism Index Range',
    min_tourism_index, max_tourism_index,
    (min_tourism_index, max_tourism_index)
)

# Apply Tourism Index filter
if not filtered_data.empty:
    filtered_data = filtered_data[(filtered_data['Tourism Index'] >= tourism_index_filter_range[0]) &
                                  (filtered_data['Tourism Index'] <= tourism_index_filter_range[1])]


# Visualization 1: Bar chart of Count of Towns by Tourism Index (filtered by search and index)
st.subheader('Distribution of Tourism Index Scores (Filtered by Town Search and Index)')
# Aggregate data for the bar chart: count towns for each tourism index value
if not filtered_data.empty:
    tourism_index_counts = filtered_data['Tourism Index'].value_counts().reset_index()
    tourism_index_counts.columns = ['Tourism Index', 'Number of Towns']

    chart1 = alt.Chart(tourism_index_counts).mark_bar().encode(
        x=alt.X('Tourism Index:O', title='Tourism Index'), # Treat Tourism Index as ordinal for discrete bars
        y=alt.Y('Number of Towns', title='Number of Towns'),
        tooltip=['Tourism Index', 'Number of Towns']
    ).properties(
        title='Number of Towns by Tourism Index (Filtered by Search and Index)'
    ).interactive() # Make the chart interactive (zoom/pan)
    st.altair_chart(chart1, use_container_width=True)
else:
    st.write("No data matches the selected town and tourism index filters for the bar chart.")


# Interactive feature 3: Slider for filtering by Total number of restaurants (for scatter plot)
st.subheader('Explore Tourism Index vs. Infrastructure (Filtered by Town Search, Index, and Restaurants)')
# Ensure filtered_data has data before calculating min/max for restaurants
if not filtered_data.empty:
    min_restaurants, max_restaurants = int(filtered_data['Total number of restaurants'].min()), int(filtered_data['Total number of restaurants'].max())
    # Handle the case where min and max are the same after filtering
    if min_restaurants == max_restaurants:
        restaurant_count_filter = st.slider('Filter by Minimum Number of Restaurants for Scatter Plot', min_restaurants, max_restaurants, min_restaurants)
    else:
        restaurant_count_filter = st.slider('Filter by Minimum Number of Restaurants for Scatter Plot', min_restaurants, max_restaurants, min_restaurants)

    # Filter data based on the restaurant slider value (applied to already town and index filtered data)
    filtered_data_restaurants = filtered_data[filtered_data['Total number of restaurants'] >= restaurant_count_filter]

    # Visualization 2 (Updated): Scatter plot of Total number of restaurants vs. Total number of cafes, colored by Tourism Index with all filters applied
    st.subheader('Tourism Index vs. Restaurants and Cafes (Filtered)')

    if not filtered_data_restaurants.empty:
        chart2_final = alt.Chart(filtered_data_restaurants).mark_circle(size=60).encode(
            x=alt.X('Total number of restaurants', title='Total Number of Restaurants'),
            y=alt.Y('Total number of cafes', title='Total Number of Cafes'),
            color=alt.Color('Tourism Index:O', title='Tourism Index'), # Color points by Tourism Index, treat as ordinal
            tooltip=['Town', 'Tourism Index', 'Total number of restaurants', 'Total number of cafes', 'refArea'] # Added refArea to tooltip
        ).properties(
            title='Tourism Index vs. Restaurants and Cafes (Filtered)'
        ).interactive() # Make the chart interactive (zoom/pan)
        st.altair_chart(chart2_final, use_container_width=True)
    else:
        st.write("No data matches the selected filters for the scatter plot.")

else:
    st.write("No data matches the selected town and tourism index filters for the scatter plot.")


# New Feature: Display towns with a low tourism index (filtered by town search and index)
st.subheader('Towns with Low Tourism Index (Filtered)')
# Ensure filtered_data has data before calculating min/max for low tourism index slider
if not filtered_data.empty:
    min_tourism_index_low, max_tourism_index_low = int(filtered_data['Tourism Index'].min()), int(filtered_data['Tourism Index'].max())
    low_tourism_index_threshold = st.slider(
        'Select maximum Tourism Index for "Low"',
        min_tourism_index_low, max_tourism_index_low,
        min(3, max_tourism_index_low) # Default to 3 or the max if less than 3
    )
    low_tourism_towns = filtered_data[filtered_data['Tourism Index'] <= low_tourism_index_threshold][['Town', 'Tourism Index', 'refArea']]

    if not low_tourism_towns.empty:
        st.write(low_tourism_towns)
    else:
        st.write(f"No towns found with a Tourism Index less than or equal to {low_tourism_index_threshold} matching the current filters.")
else:
    st.write("No data matches the selected town and tourism index filters to display towns with low tourism index.")

"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import altair as alt
# 
# # Define the Streamlit app title
# st.title('Tourism in Lebanese Districts')
# 
# # Define the data path
# # When deploying to Streamlit Community Cloud, the data file needs to be
# # in the same repository as your app file, or accessible via a URL.
# # Assuming '1bda8ed51f92f19f06887a3d1c8afaba.csv' is in the same directory
# DATA_PATH = "1bda8ed51f92f19f06887a3d1c8afaba.csv"
# 
# # Load the data with caching
# @st.cache_data
# def load_data(data_path):
#     data = pd.read_csv(data_path)
#     # Ensure 'refArea' and 'Town' are treated as strings
#     if 'refArea' in data.columns:
#         data['refArea'] = data['refArea'].astype(str)
#     if 'Town' in data.columns:
#         data['Town'] = data['Town'].astype(str)
#     return data
# 
# # Load the data and display loading status
# data_load_state = st.text('Loading data...')
# data = load_data(DATA_PATH)
# data_load_state.text("Done! Loading data...")
# 
# # Interactive feature 1: Display raw data checkbox
# if st.checkbox('Show raw data'):
#     st.subheader('Raw data')
#     st.write(data)
# 
# # Interactive feature: Search bar for filtering by Town
# st.sidebar.subheader('Filter Data by Town')
# town_search_term = st.sidebar.text_input('Enter Town Name to Search')
# 
# # Filter data based on search term
# if town_search_term:
#     # Use case=False for case-insensitive search and na=False to handle potential NaN values
#     filtered_data = data[data['Town'].str.contains(town_search_term, case=False, na=False)]
# else:
#     filtered_data = data.copy() # Use a copy to avoid modifying the original cached data
# 
# # Interactive feature: Slider for filtering by Tourism Index
# st.sidebar.subheader('Filter by Tourism Index')
# min_tourism_index, max_tourism_index = int(data['Tourism Index'].min()), int(data['Tourism Index'].max())
# tourism_index_filter_range = st.sidebar.slider(
#     'Select Tourism Index Range',
#     min_tourism_index, max_tourism_index,
#     (min_tourism_index, max_tourism_index)
# )
# 
# # Apply Tourism Index filter
# if not filtered_data.empty:
#     filtered_data = filtered_data[(filtered_data['Tourism Index'] >= tourism_index_filter_range[0]) &
#                                   (filtered_data['Tourism Index'] <= tourism_index_filter_range[1])]
# 
# 
# # Visualization 1: Bar chart of Count of Towns by Tourism Index (filtered by search and index)
# st.subheader('Distribution of Tourism Index Scores (Filtered by Town Search and Index)')
# # Aggregate data for the bar chart: count towns for each tourism index value
# if not filtered_data.empty:
#     tourism_index_counts = filtered_data['Tourism Index'].value_counts().reset_index()
#     tourism_index_counts.columns = ['Tourism Index', 'Number of Towns']
# 
#     chart1 = alt.Chart(tourism_index_counts).mark_bar().encode(
#         x=alt.X('Tourism Index:O', title='Tourism Index'), # Treat Tourism Index as ordinal for discrete bars
#         y=alt.Y('Number of Towns', title='Number of Towns'),
#         tooltip=['Tourism Index', 'Number of Towns']
#     ).properties(
#         title='Number of Towns by Tourism Index (Filtered by Search and Index)'
#     ).interactive() # Make the chart interactive (zoom/pan)
#     st.altair_chart(chart1, use_container_width=True)
# else:
#     st.write("No data matches the selected town and tourism index filters for the bar chart.")
# 
# 
# # Interactive feature 3: Slider for filtering by Total number of restaurants (for scatter plot)
# st.subheader('Explore Tourism Index vs. Infrastructure (Filtered by Town Search, Index, and Restaurants)')
# # Ensure filtered_data has data before calculating min/max for restaurants
# if not filtered_data.empty:
#     min_restaurants, max_restaurants = int(filtered_data['Total number of restaurants'].min()), int(filtered_data['Total number of restaurants'].max())
#     # Handle the case where min and max are the same after filtering
#     if min_restaurants == max_restaurants:
#         restaurant_count_filter = st.slider('Filter by Minimum Number of Restaurants for Scatter Plot', min_restaurants, max_restaurants, min_restaurants)
#     else:
#         restaurant_count_filter = st.slider('Filter by Minimum Number of Restaurants for Scatter Plot', min_restaurants, max_restaurants, min_restaurants)
# 
#     # Filter data based on the restaurant slider value (applied to already town and index filtered data)
#     filtered_data_restaurants = filtered_data[filtered_data['Total number of restaurants'] >= restaurant_count_filter]
# 
#     # Visualization 2 (Updated): Scatter plot of Total number of restaurants vs. Total number of cafes, colored by Tourism Index with all filters applied
#     st.subheader('Tourism Index vs. Restaurants and Cafes (Filtered)')
# 
#     if not filtered_data_restaurants.empty:
#         chart2_final = alt.Chart(filtered_data_restaurants).mark_circle(size=60).encode(
#             x=alt.X('Total number of restaurants', title='Total Number of Restaurants'),
#             y=alt.Y('Total number of cafes', title='Total Number of Cafes'),
#             color=alt.Color('Tourism Index:O', title='Tourism Index'), # Color points by Tourism Index, treat as ordinal
#             tooltip=['Town', 'Tourism Index', 'Total number of restaurants', 'Total number of cafes', 'refArea'] # Added refArea to tooltip
#         ).properties(
#             title='Tourism Index vs. Restaurants and Cafes (Filtered)'
#         ).interactive() # Make the chart interactive (zoom/pan)
#         st.altair_chart(chart2_final, use_container_width=True)
#     else:
#         st.write("No data matches the selected filters for the scatter plot.")
# 
# else:
#     st.write("No data matches the selected town and tourism index filters for the scatter plot.")
# 
# 
# # New Feature: Display towns with a low tourism index (filtered by town search and index)
# st.subheader('Towns with Low Tourism Index (Filtered)')
# # Ensure filtered_data has data before calculating min/max for low tourism index slider
# if not filtered_data.empty:
#     min_tourism_index_low, max_tourism_index_low = int(filtered_data['Tourism Index'].min()), int(filtered_data['Tourism Index'].max())
#     low_tourism_index_threshold = st.slider(
#         'Select maximum Tourism Index for "Low"',
#         min_tourism_index_low, max_tourism_index_low,
#         min(3, max_tourism_index_low) # Default to 3 or the max if less than 3
#     )
#     low_tourism_towns = filtered_data[filtered_data['Tourism Index'] <= low_tourism_index_threshold][['Town', 'Tourism Index', 'refArea']]
# 
#     if not low_tourism_towns.empty:
#         st.write(low_tourism_towns)
#     else:
#         st.write(f"No towns found with a Tourism Index less than or equal to {low_tourism_index_threshold} matching the current filters.")
# else:
#     st.write("No data matches the selected town and tourism index filters to display towns with low tourism index.")

"""**Reasoning**:
The Streamlit code has been successfully written to `app.py`. Now, run the Streamlit application using the `streamlit run` command on the new `.py` file in the background.


"""

get_ipython().system('streamlit run app.py &')
